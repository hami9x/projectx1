// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: player.proto

#ifndef PROTOBUF_player_2eproto__INCLUDED
#define PROTOBUF_player_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_player_2eproto();
void protobuf_AssignDesc_player_2eproto();
void protobuf_ShutdownFile_player_2eproto();

class PlayerMove;
class PlayerChange;
class PlayerUpdate;
class Update;

// ===================================================================

class PlayerMove : public ::google::protobuf::MessageLite {
 public:
  PlayerMove();
  virtual ~PlayerMove();

  PlayerMove(const PlayerMove& from);

  inline PlayerMove& operator=(const PlayerMove& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerMove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerMove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerMove* other);

  // implements Message ----------------------------------------------

  PlayerMove* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerMove& from);
  void MergeFrom(const PlayerMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float mvectx = 2;
  inline bool has_mvectx() const;
  inline void clear_mvectx();
  static const int kMvectxFieldNumber = 2;
  inline float mvectx() const;
  inline void set_mvectx(float value);

  // required float mvecty = 3;
  inline bool has_mvecty() const;
  inline void clear_mvecty();
  static const int kMvectyFieldNumber = 3;
  inline float mvecty() const;
  inline void set_mvecty(float value);

  // @@protoc_insertion_point(class_scope:PlayerMove)
 private:
  inline void set_has_mvectx();
  inline void clear_has_mvectx();
  inline void set_has_mvecty();
  inline void clear_has_mvecty();

  float mvectx_;
  float mvecty_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_player_2eproto();
  #endif
  friend void protobuf_AssignDesc_player_2eproto();
  friend void protobuf_ShutdownFile_player_2eproto();

  void InitAsDefaultInstance();
  static PlayerMove* default_instance_;
};
// -------------------------------------------------------------------

class PlayerChange : public ::google::protobuf::MessageLite {
 public:
  PlayerChange();
  virtual ~PlayerChange();

  PlayerChange(const PlayerChange& from);

  inline PlayerChange& operator=(const PlayerChange& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerChange& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerChange* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerChange* other);

  // implements Message ----------------------------------------------

  PlayerChange* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerChange& from);
  void MergeFrom(const PlayerChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // required float angle = 2;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 2;
  inline float angle() const;
  inline void set_angle(float value);

  // optional .PlayerMove move = 3;
  inline bool has_move() const;
  inline void clear_move();
  static const int kMoveFieldNumber = 3;
  inline const ::PlayerMove& move() const;
  inline ::PlayerMove* mutable_move();
  inline ::PlayerMove* release_move();
  inline void set_allocated_move(::PlayerMove* move);

  // @@protoc_insertion_point(class_scope:PlayerChange)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_move();
  inline void clear_has_move();

  ::google::protobuf::int32 time_;
  float angle_;
  ::PlayerMove* move_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_player_2eproto();
  #endif
  friend void protobuf_AssignDesc_player_2eproto();
  friend void protobuf_ShutdownFile_player_2eproto();

  void InitAsDefaultInstance();
  static PlayerChange* default_instance_;
};
// -------------------------------------------------------------------

class PlayerUpdate : public ::google::protobuf::MessageLite {
 public:
  PlayerUpdate();
  virtual ~PlayerUpdate();

  PlayerUpdate(const PlayerUpdate& from);

  inline PlayerUpdate& operator=(const PlayerUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerUpdate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerUpdate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerUpdate* other);

  // implements Message ----------------------------------------------

  PlayerUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerUpdate& from);
  void MergeFrom(const PlayerUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 player = 1;
  inline bool has_player() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 1;
  inline ::google::protobuf::int32 player() const;
  inline void set_player(::google::protobuf::int32 value);

  // required float angle = 2;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 2;
  inline float angle() const;
  inline void set_angle(float value);

  // required float posx = 3;
  inline bool has_posx() const;
  inline void clear_posx();
  static const int kPosxFieldNumber = 3;
  inline float posx() const;
  inline void set_posx(float value);

  // required float posy = 4;
  inline bool has_posy() const;
  inline void clear_posy();
  static const int kPosyFieldNumber = 4;
  inline float posy() const;
  inline void set_posy(float value);

  // required float velx = 5;
  inline bool has_velx() const;
  inline void clear_velx();
  static const int kVelxFieldNumber = 5;
  inline float velx() const;
  inline void set_velx(float value);

  // required float vely = 6;
  inline bool has_vely() const;
  inline void clear_vely();
  static const int kVelyFieldNumber = 6;
  inline float vely() const;
  inline void set_vely(float value);

  // @@protoc_insertion_point(class_scope:PlayerUpdate)
 private:
  inline void set_has_player();
  inline void clear_has_player();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_posx();
  inline void clear_has_posx();
  inline void set_has_posy();
  inline void clear_has_posy();
  inline void set_has_velx();
  inline void clear_has_velx();
  inline void set_has_vely();
  inline void clear_has_vely();

  ::google::protobuf::int32 player_;
  float angle_;
  float posx_;
  float posy_;
  float velx_;
  float vely_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_player_2eproto();
  #endif
  friend void protobuf_AssignDesc_player_2eproto();
  friend void protobuf_ShutdownFile_player_2eproto();

  void InitAsDefaultInstance();
  static PlayerUpdate* default_instance_;
};
// -------------------------------------------------------------------

class Update : public ::google::protobuf::MessageLite {
 public:
  Update();
  virtual ~Update();

  Update(const Update& from);

  inline Update& operator=(const Update& from) {
    CopyFrom(from);
    return *this;
  }

  static const Update& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Update* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Update* other);

  // implements Message ----------------------------------------------

  Update* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Update& from);
  void MergeFrom(const Update& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // repeated .PlayerUpdate players = 2;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 2;
  inline const ::PlayerUpdate& players(int index) const;
  inline ::PlayerUpdate* mutable_players(int index);
  inline ::PlayerUpdate* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerUpdate >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerUpdate >*
      mutable_players();

  // @@protoc_insertion_point(class_scope:Update)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::int64 time_;
  ::google::protobuf::RepeatedPtrField< ::PlayerUpdate > players_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_player_2eproto();
  #endif
  friend void protobuf_AssignDesc_player_2eproto();
  friend void protobuf_ShutdownFile_player_2eproto();

  void InitAsDefaultInstance();
  static Update* default_instance_;
};
// ===================================================================


// ===================================================================

// PlayerMove

// required float mvectx = 2;
inline bool PlayerMove::has_mvectx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerMove::set_has_mvectx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerMove::clear_has_mvectx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerMove::clear_mvectx() {
  mvectx_ = 0;
  clear_has_mvectx();
}
inline float PlayerMove::mvectx() const {
  return mvectx_;
}
inline void PlayerMove::set_mvectx(float value) {
  set_has_mvectx();
  mvectx_ = value;
}

// required float mvecty = 3;
inline bool PlayerMove::has_mvecty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerMove::set_has_mvecty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerMove::clear_has_mvecty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerMove::clear_mvecty() {
  mvecty_ = 0;
  clear_has_mvecty();
}
inline float PlayerMove::mvecty() const {
  return mvecty_;
}
inline void PlayerMove::set_mvecty(float value) {
  set_has_mvecty();
  mvecty_ = value;
}

// -------------------------------------------------------------------

// PlayerChange

// required int32 time = 1;
inline bool PlayerChange::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerChange::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerChange::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerChange::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 PlayerChange::time() const {
  return time_;
}
inline void PlayerChange::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// required float angle = 2;
inline bool PlayerChange::has_angle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerChange::set_has_angle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerChange::clear_has_angle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerChange::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float PlayerChange::angle() const {
  return angle_;
}
inline void PlayerChange::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// optional .PlayerMove move = 3;
inline bool PlayerChange::has_move() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerChange::set_has_move() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerChange::clear_has_move() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerChange::clear_move() {
  if (move_ != NULL) move_->::PlayerMove::Clear();
  clear_has_move();
}
inline const ::PlayerMove& PlayerChange::move() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return move_ != NULL ? *move_ : *default_instance().move_;
#else
  return move_ != NULL ? *move_ : *default_instance_->move_;
#endif
}
inline ::PlayerMove* PlayerChange::mutable_move() {
  set_has_move();
  if (move_ == NULL) move_ = new ::PlayerMove;
  return move_;
}
inline ::PlayerMove* PlayerChange::release_move() {
  clear_has_move();
  ::PlayerMove* temp = move_;
  move_ = NULL;
  return temp;
}
inline void PlayerChange::set_allocated_move(::PlayerMove* move) {
  delete move_;
  move_ = move;
  if (move) {
    set_has_move();
  } else {
    clear_has_move();
  }
}

// -------------------------------------------------------------------

// PlayerUpdate

// required int32 player = 1;
inline bool PlayerUpdate::has_player() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerUpdate::set_has_player() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerUpdate::clear_has_player() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerUpdate::clear_player() {
  player_ = 0;
  clear_has_player();
}
inline ::google::protobuf::int32 PlayerUpdate::player() const {
  return player_;
}
inline void PlayerUpdate::set_player(::google::protobuf::int32 value) {
  set_has_player();
  player_ = value;
}

// required float angle = 2;
inline bool PlayerUpdate::has_angle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerUpdate::set_has_angle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerUpdate::clear_has_angle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerUpdate::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float PlayerUpdate::angle() const {
  return angle_;
}
inline void PlayerUpdate::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// required float posx = 3;
inline bool PlayerUpdate::has_posx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerUpdate::set_has_posx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerUpdate::clear_has_posx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerUpdate::clear_posx() {
  posx_ = 0;
  clear_has_posx();
}
inline float PlayerUpdate::posx() const {
  return posx_;
}
inline void PlayerUpdate::set_posx(float value) {
  set_has_posx();
  posx_ = value;
}

// required float posy = 4;
inline bool PlayerUpdate::has_posy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerUpdate::set_has_posy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerUpdate::clear_has_posy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerUpdate::clear_posy() {
  posy_ = 0;
  clear_has_posy();
}
inline float PlayerUpdate::posy() const {
  return posy_;
}
inline void PlayerUpdate::set_posy(float value) {
  set_has_posy();
  posy_ = value;
}

// required float velx = 5;
inline bool PlayerUpdate::has_velx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerUpdate::set_has_velx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerUpdate::clear_has_velx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerUpdate::clear_velx() {
  velx_ = 0;
  clear_has_velx();
}
inline float PlayerUpdate::velx() const {
  return velx_;
}
inline void PlayerUpdate::set_velx(float value) {
  set_has_velx();
  velx_ = value;
}

// required float vely = 6;
inline bool PlayerUpdate::has_vely() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerUpdate::set_has_vely() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerUpdate::clear_has_vely() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerUpdate::clear_vely() {
  vely_ = 0;
  clear_has_vely();
}
inline float PlayerUpdate::vely() const {
  return vely_;
}
inline void PlayerUpdate::set_vely(float value) {
  set_has_vely();
  vely_ = value;
}

// -------------------------------------------------------------------

// Update

// required int64 time = 1;
inline bool Update::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Update::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Update::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Update::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 Update::time() const {
  return time_;
}
inline void Update::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// repeated .PlayerUpdate players = 2;
inline int Update::players_size() const {
  return players_.size();
}
inline void Update::clear_players() {
  players_.Clear();
}
inline const ::PlayerUpdate& Update::players(int index) const {
  return players_.Get(index);
}
inline ::PlayerUpdate* Update::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::PlayerUpdate* Update::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerUpdate >&
Update::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerUpdate >*
Update::mutable_players() {
  return &players_;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_player_2eproto__INCLUDED
